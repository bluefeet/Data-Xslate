=pod

=head1 NAME

Data::Xslate - Templatize your data.

=head1 SYNOPSIS

    use Data::Xslate;
    
    my $xslate = Data::Xslate->new();
    
    my $data = $xslate->render(
        {
            user => {
                login => 'john',
                email => '<: $login :>@example.com',
                name  => 'John',
            },
            email => {
                to      => '=:user.email',
                subject => 'Hello <: $user.name :>!',
            },
            'email.from' => 'george@example.com',
        },
    );
    
    # This would produce the following:
    # $data->{email} = {
    #     to => 'john@example.com',
    #     from => 'george@example.com',
    #     subject => 'Hello John!',
    # }

=head1 DESCRIPTION

This module provides a syntax for templatizing data structures.

The most likely use-case is adding some flexibility to configuration
files.

=head1 SUBSTITUTION

    {
        foo => 14,
        bar => '=:foo',
    }
    # { foo=>14, bar=>14 }

This injects the target value.  This can be used for any data type.  For
example we can substitute an array:

    {
        foo => [1,2,3],
        bar => '=:foo',
    }
    # { foo=>[1,2,3], bar=>[1,2,3] }

=head1 TEMPLATING

    {
        foo => 'green',
        bar => 'It is <: $foo :>!',
    }
    # { foo=>'green', bar=>'It is green!' }

The syntax for templating is provided by L<Text::Xslate>, so
there is a lot of power here including being able to do math
and string mangling.

=head1 SCOPE

When using either L</SUBSTITUTION> or L</TEMPLATING> you specify a key to be
included.  This key is found using scope-aware rules where the key is searched for
in a similar fashion to how you'd expect when dealing with lexical variables in
programming.

For example, you can refer to a key in the same scope:

    { a=>1, b=>'=:a' }

You may refer to a key in a lower scope:

    { a=>{ b=>1 }, c=>'=:a.b' }

You may refer to a key in a higher scope:

    { a=>{ b=>'=:c' }, c=>1 }

You may refer to a key in a higher scope that is nested:

    { a=>{ b=>'=:c.d' }, c=>{ d=>1 } }

The logic behind this is pretty flexible, so more complex use cases will
just work like you would expect.

If you'd rather avoid this scoping you can prepend any key with a dot, C<.>, and
it will be looked for at the root hash of the config tree only.

=head1 NESTED KEYS

When setting a key value the key can point deeper into the structure by separating keys with
a dot, C<.>.  Consider this:

    { a=>{ b=>1 }, 'a.b'=>2 }

Which produces:

    { a=>{ b=>2 } }

=head1 ARGUMENTS

Any arguments you pass to C<new>, which this class does not directly
handle, will be used when creating the L</xslate> object.  So, any
arguments which L<Text::Xslate> supports may be set.  For example:

    my $xslate = Data::Xslate->new(
        substitution_tag => ']]', # A Data::Xslate argument.
        verbose          => 2,    # A Text::Xslate option.
    );

=head2 substitution_tag

The string to look for at the beginning of any string value which
signifies L</SUBSTITUTION>.  Defaults to C<=:>.

=head1 METHODS

=head2 render

    my $data_out = $xslate->render( $data_in );

=head1 AUTHOR

Aran Clary Deltac <bluefeetE<64>gmail.com>

=head1 ACKNOWLEDGEMENTS

Thanks to L<ZipRecruiter|https://www.ziprecruiter.com/>
for encouraging their employees to contribute back to the open
source ecosystem.  Without their dedication to quality software
development this distribution would not exist.

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
